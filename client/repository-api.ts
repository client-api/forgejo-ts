/* tslint:disable */
/* eslint-disable */
/**
 * Forgejo API.
 * This documentation describes the Forgejo API.
 *
 * The version of the OpenAPI document: 1.20.5+0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { APIError } from '../models';
// @ts-ignore
import { Activity } from '../models';
// @ts-ignore
import { AddCollaboratorOption } from '../models';
// @ts-ignore
import { AnnotatedTag } from '../models';
// @ts-ignore
import { Attachment } from '../models';
// @ts-ignore
import { Branch } from '../models';
// @ts-ignore
import { BranchProtection } from '../models';
// @ts-ignore
import { ChangeFilesOptions } from '../models';
// @ts-ignore
import { ChangedFile } from '../models';
// @ts-ignore
import { CombinedStatus } from '../models';
// @ts-ignore
import { Commit } from '../models';
// @ts-ignore
import { CommitStatus } from '../models';
// @ts-ignore
import { ContentsResponse } from '../models';
// @ts-ignore
import { CreateBranchProtectionOption } from '../models';
// @ts-ignore
import { CreateBranchRepoOption } from '../models';
// @ts-ignore
import { CreateFileOptions } from '../models';
// @ts-ignore
import { CreateForkOption } from '../models';
// @ts-ignore
import { CreateHookOption } from '../models';
// @ts-ignore
import { CreateKeyOption } from '../models';
// @ts-ignore
import { CreatePullRequestOption } from '../models';
// @ts-ignore
import { CreatePullReviewOptions } from '../models';
// @ts-ignore
import { CreatePushMirrorOption } from '../models';
// @ts-ignore
import { CreateReleaseOption } from '../models';
// @ts-ignore
import { CreateRepoOption } from '../models';
// @ts-ignore
import { CreateStatusOption } from '../models';
// @ts-ignore
import { CreateTagOption } from '../models';
// @ts-ignore
import { CreateWikiPageOptions } from '../models';
// @ts-ignore
import { DeleteFileOptions } from '../models';
// @ts-ignore
import { DeployKey } from '../models';
// @ts-ignore
import { DismissPullReviewOptions } from '../models';
// @ts-ignore
import { EditAttachmentOptions } from '../models';
// @ts-ignore
import { EditBranchProtectionOption } from '../models';
// @ts-ignore
import { EditGitHookOption } from '../models';
// @ts-ignore
import { EditHookOption } from '../models';
// @ts-ignore
import { EditPullRequestOption } from '../models';
// @ts-ignore
import { EditReleaseOption } from '../models';
// @ts-ignore
import { EditRepoOption } from '../models';
// @ts-ignore
import { FileDeleteResponse } from '../models';
// @ts-ignore
import { FileResponse } from '../models';
// @ts-ignore
import { FilesResponse } from '../models';
// @ts-ignore
import { GenerateRepoOption } from '../models';
// @ts-ignore
import { GitBlobResponse } from '../models';
// @ts-ignore
import { GitHook } from '../models';
// @ts-ignore
import { GitTreeResponse } from '../models';
// @ts-ignore
import { Hook } from '../models';
// @ts-ignore
import { Issue } from '../models';
// @ts-ignore
import { IssueConfig } from '../models';
// @ts-ignore
import { IssueConfigValidation } from '../models';
// @ts-ignore
import { IssueTemplate } from '../models';
// @ts-ignore
import { MergePullRequestOption } from '../models';
// @ts-ignore
import { MigrateRepoOptions } from '../models';
// @ts-ignore
import { NewIssuePinsAllowed } from '../models';
// @ts-ignore
import { Note } from '../models';
// @ts-ignore
import { PullRequest } from '../models';
// @ts-ignore
import { PullReview } from '../models';
// @ts-ignore
import { PullReviewComment } from '../models';
// @ts-ignore
import { PullReviewRequestOptions } from '../models';
// @ts-ignore
import { PushMirror } from '../models';
// @ts-ignore
import { Reference } from '../models';
// @ts-ignore
import { Release } from '../models';
// @ts-ignore
import { RepoCollaboratorPermission } from '../models';
// @ts-ignore
import { RepoTopicOptions } from '../models';
// @ts-ignore
import { Repository } from '../models';
// @ts-ignore
import { SearchResults } from '../models';
// @ts-ignore
import { SubmitPullReviewOptions } from '../models';
// @ts-ignore
import { Tag } from '../models';
// @ts-ignore
import { Team } from '../models';
// @ts-ignore
import { TopicName } from '../models';
// @ts-ignore
import { TopicResponse } from '../models';
// @ts-ignore
import { TrackedTime } from '../models';
// @ts-ignore
import { TransferRepoOption } from '../models';
// @ts-ignore
import { UpdateFileOptions } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { WatchInfo } from '../models';
// @ts-ignore
import { WikiCommitList } from '../models';
// @ts-ignore
import { WikiPage } from '../models';
// @ts-ignore
import { WikiPageMetaData } from '../models';
/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptRepoTransfer: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('acceptRepoTransfer', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('acceptRepoTransfer', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/transfer/accept`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo: async (body?: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFork: async (owner: string, repo: string, body?: CreateForkOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('createFork', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('createFork', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRepo: async (templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateOwner' is not null or undefined
            assertParamExists('generateRepo', 'templateOwner', templateOwner)
            // verify required parameter 'templateRepo' is not null or undefined
            assertParamExists('generateRepo', 'templateRepo', templateRepo)
            const localVarPath = `/repos/{template_owner}/{template_repo}/generate`
                .replace(`{${"template_owner"}}`, encodeURIComponent(String(templateOwner)))
                .replace(`{${"template_repo"}}`, encodeURIComponent(String(templateRepo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotatedTag: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getAnnotatedTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getAnnotatedTag', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('getAnnotatedTag', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/tags/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlob: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getBlob', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getBlob', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('getBlob', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/blobs/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree: async (owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getTree', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getTree', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('getTree', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/trees/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForks: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('listForks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('listForks', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectRepoTransfer: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('rejectRepoTransfer', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('rejectRepoTransfer', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/transfer/reject`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddCollaborator: async (owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddCollaborator', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddCollaborator', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoAddCollaborator', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary add a push mirror to the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePushMirrorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddPushMirror: async (owner: string, repo: string, body?: CreatePushMirrorOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddPushMirror', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddPushMirror', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddTeam', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddTeam', 'repo', repo)
            // verify required parameter 'team' is not null or undefined
            assertParamExists('repoAddTeam', 'team', team)
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTopic: async (owner: string, repo: string, topic: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddTopic', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddTopic', 'repo', repo)
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('repoAddTopic', 'topic', topic)
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply diff patch to repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoApplyDiffPatch: async (owner: string, repo: string, body: UpdateFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoApplyDiffPatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoApplyDiffPatch', 'repo', repo)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoApplyDiffPatch', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/diffpatch`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel the scheduled auto merge for the given pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCancelScheduledAutoMerge: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCancelScheduledAutoMerge', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCancelScheduledAutoMerge', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoCancelScheduledAutoMerge', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify multiple files in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {ChangeFilesOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoChangeFiles: async (owner: string, repo: string, body: ChangeFilesOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoChangeFiles', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoChangeFiles', 'repo', repo)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoChangeFiles', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckCollaborator: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCheckCollaborator', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCheckCollaborator', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoCheckCollaborator', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCheckTeam', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCheckTeam', 'repo', repo)
            // verify required parameter 'team' is not null or undefined
            assertParamExists('repoCheckTeam', 'team', team)
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranch: async (owner: string, repo: string, body?: CreateBranchRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateBranch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateBranch', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranchProtection: async (owner: string, repo: string, body?: CreateBranchProtectionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateBranchProtection', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {CreateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateFile: async (owner: string, repo: string, filepath: string, body: CreateFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoCreateFile', 'filepath', filepath)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoCreateFile', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateHook: async (owner: string, repo: string, body?: CreateHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateHook', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateKey: async (owner: string, repo: string, body?: CreateKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateKey', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullRequest: async (owner: string, repo: string, body?: CreatePullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreatePullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreatePullRequest', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {CreatePullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReview: async (owner: string, repo: string, index: number, body: CreatePullReviewOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreatePullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreatePullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoCreatePullReview', 'index', index)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoCreatePullReview', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReviewRequests: async (owner: string, repo: string, index: number, body: PullReviewRequestOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'index', index)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateRelease: async (owner: string, repo: string, body?: CreateReleaseOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateRelease', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateReleaseAttachment: async (owner: string, repo: string, id: number, attachment: File, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'id', id)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'attachment', attachment)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (attachment !== undefined) { 
                localVarFormParams.append('attachment', attachment as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateStatus: async (owner: string, repo: string, sha: string, body?: CreateStatusOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateStatus', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateStatus', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoCreateStatus', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateTag: async (owner: string, repo: string, body?: CreateTagOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateTag', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateWikiPage: async (owner: string, repo: string, body?: CreateWikiPageOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateWikiPage', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/wiki/new`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDelete: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDelete', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDelete', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranch: async (owner: string, repo: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteBranch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('repoDeleteBranch', 'branch', branch)
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranchProtection: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteBranchProtection', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoDeleteBranchProtection', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteCollaborator: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteCollaborator', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteCollaborator', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoDeleteCollaborator', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {DeleteFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteFile: async (owner: string, repo: string, filepath: string, body: DeleteFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoDeleteFile', 'filepath', filepath)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoDeleteFile', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitHook: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteGitHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteGitHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteGitHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteHook: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteKey: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteKey', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteKey', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeletePullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeletePullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDeletePullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeletePullReview', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReviewRequests: async (owner: string, repo: string, index: number, body: PullReviewRequestOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'index', index)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes a push mirror from a repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of the pushMirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePushMirror: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeletePushMirror', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeletePushMirror', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoDeletePushMirror', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteRelease: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteRelease', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteRelease', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseByTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteReleaseByTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteReleaseByTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoDeleteReleaseByTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a repository\'s tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoDeleteTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteTeam', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteTeam', 'repo', repo)
            // verify required parameter 'team' is not null or undefined
            assertParamExists('repoDeleteTeam', 'team', team)
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTopic: async (owner: string, repo: string, topic: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteTopic', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteTopic', 'repo', repo)
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('repoDeleteTopic', 'topic', topic)
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteWikiPage: async (owner: string, repo: string, pageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteWikiPage', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoDeleteWikiPage', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {DismissPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDismissPullReview: async (owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDismissPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDismissPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDismissPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDismissPullReview', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoDismissPullReview', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadCommitDiffOrPatch: async (owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'sha', sha)
            // verify required parameter 'diffType' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'diffType', diffType)
            const localVarPath = `/repos/{owner}/{repo}/git/commits/{sha}.{diffType}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)))
                .replace(`{${"diffType"}}`, encodeURIComponent(String(diffType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullDiffOrPatch: async (owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'index', index)
            // verify required parameter 'diffType' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'diffType', diffType)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}.{diffType}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"diffType"}}`, encodeURIComponent(String(diffType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (binary !== undefined) {
                localVarQueryParameter['binary'] = binary;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a repository\'s properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEdit: async (owner: string, repo: string, body?: EditRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEdit', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEdit', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditBranchProtection: async (owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditBranchProtection', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoEditBranchProtection', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditGitHook: async (owner: string, repo: string, id: string, body?: EditGitHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditGitHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditGitHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditGitHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditHook: async (owner: string, repo: string, id: number, body?: EditHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditPullRequest: async (owner: string, repo: string, index: number, body?: EditPullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditPullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditPullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoEditPullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditRelease: async (owner: string, repo: string, id: number, body?: EditReleaseOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditRelease', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditRelease', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditWikiPage: async (owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditWikiPage', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoEditWikiPage', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGet: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGet', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGet', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
         * @param {string} [path] filepath of a file/dir
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
         * @param {string} [not] commits that match the given specifier will not be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAllCommits: async (owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetAllCommits', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetAllCommits', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/commits`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sha !== undefined) {
                localVarQueryParameter['sha'] = sha;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (stat !== undefined) {
                localVarQueryParameter['stat'] = stat;
            }

            if (verification !== undefined) {
                localVarQueryParameter['verification'] = verification;
            }

            if (files !== undefined) {
                localVarQueryParameter['files'] = files;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (not !== undefined) {
                localVarQueryParameter['not'] = not;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetArchive: async (owner: string, repo: string, archive: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetArchive', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetArchive', 'repo', repo)
            // verify required parameter 'archive' is not null or undefined
            assertParamExists('repoGetArchive', 'archive', archive)
            const localVarPath = `/repos/{owner}/{repo}/archive/{archive}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"archive"}}`, encodeURIComponent(String(archive)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAssignees: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetAssignees', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetAssignees', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/assignees`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranch: async (owner: string, repo: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetBranch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('repoGetBranch', 'branch', branch)
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranchProtection: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetBranchProtection', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoGetBranchProtection', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetByID: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetByID', 'id', id)
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetCombinedStatusByRef: async (owner: string, repo: string, ref: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetCombinedStatusByRef', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetCombinedStatusByRef', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoGetCombinedStatusByRef', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/status`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContents: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetContents', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetContents', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetContents', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContentsList: async (owner: string, repo: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetContentsList', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetContentsList', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/contents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetEditorConfig: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetEditorConfig', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetEditorConfig', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetEditorConfig', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/editorconfig/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetGitHook: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetGitHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetGitHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetGitHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetHook: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the issue config for a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueConfig: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetIssueConfig', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetIssueConfig', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issue_config`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueTemplates: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetIssueTemplates', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetIssueTemplates', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issue_templates`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository\'s key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetKey: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetKey', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetKey', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLanguages: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetLanguages', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetLanguages', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/languages`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLatestRelease: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetLatestRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetLatestRelease', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/releases/latest`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetNote: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetNote', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetNote', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoGetNote', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/notes/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequest: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestCommits: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullRequestCommits', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullRequestCommits', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullRequestCommits', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/commits`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get changed files for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} [skipTo] skip to given file
         * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestFiles: async (owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullRequestFiles', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullRequestFiles', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullRequestFiles', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/files`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (skipTo !== undefined) {
                localVarQueryParameter['skip-to'] = skipTo;
            }

            if (whitespace !== undefined) {
                localVarQueryParameter['whitespace'] = whitespace;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetPullReview', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReviewComments: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get push mirror of the repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of push mirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPushMirrorByRemoteName: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPushMirrorByRemoteName', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPushMirrorByRemoteName', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoGetPushMirrorByRemoteName', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFile: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRawFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRawFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetRawFile', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/raw/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file or it\'s LFS object from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFileOrLFS: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRawFileOrLFS', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRawFileOrLFS', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetRawFileOrLFS', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/media/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRelease: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRelease', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetRelease', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseByTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetReleaseByTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetReleaseByTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoGetReleaseByTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get repository permissions for a user
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRepoPermissions: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRepoPermissions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRepoPermissions', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoGetRepoPermissions', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}/permission`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReviewers: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetReviewers', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetReviewers', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetSingleCommit: async (owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetSingleCommit', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetSingleCommit', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoGetSingleCommit', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/commits/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (stat !== undefined) {
                localVarQueryParameter['stat'] = stat;
            }

            if (verification !== undefined) {
                localVarQueryParameter['verification'] = verification;
            }

            if (files !== undefined) {
                localVarQueryParameter['files'] = files;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoGetTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPage: async (owner: string, repo: string, pageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetWikiPage', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoGetWikiPage', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPageRevisions: async (owner: string, repo: string, pageName: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetWikiPageRevisions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetWikiPageRevisions', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoGetWikiPageRevisions', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/revisions/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPages: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetWikiPages', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetWikiPages', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/wiki/pages`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s activity feeds
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListActivityFeeds: async (owner: string, repo: string, date?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListActivityFeeds', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListActivityFeeds', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/activities/feeds`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListAllGitRefs: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListAllGitRefs', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListAllGitRefs', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/git/refs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranchProtection: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListBranchProtection', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranches: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListBranches', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListBranches', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListCollaborators: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListCollaborators', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListCollaborators', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/collaborators`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitHooks: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListGitHooks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListGitHooks', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitRefs: async (owner: string, repo: string, ref: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListGitRefs', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListGitRefs', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoListGitRefs', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/git/refs/{ref}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListHooks: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListHooks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListHooks', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListKeys: async (owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListKeys', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListKeys', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (keyId !== undefined) {
                localVarQueryParameter['key_id'] = keyId;
            }

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s pinned issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPinnedIssues: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPinnedIssues', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPinnedIssues', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues/pinned`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s pinned pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPinnedPullRequests: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPinnedPullRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPinnedPullRequests', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/pulls/pinned`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
         * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullRequests: async (owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPullRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPullRequests', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (milestone !== undefined) {
                localVarQueryParameter['milestone'] = milestone;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullReviews: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPullReviews', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPullReviews', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoListPullReviews', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all push mirrors of the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPushMirrors: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPushMirrors', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPushMirrors', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List release\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleaseAttachments: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListReleaseAttachments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListReleaseAttachments', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoListReleaseAttachments', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleases: async (owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListReleases', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListReleases', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }

            if (preRelease !== undefined) {
                localVarQueryParameter['pre-release'] = preRelease;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStargazers: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListStargazers', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListStargazers', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/stargazers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {RepoListStatusesSortEnum} [sort] type of sort
         * @param {RepoListStatusesStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatuses: async (owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListStatuses', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListStatuses', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoListStatuses', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
         * @param {RepoListStatusesByRefStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatusesByRef: async (owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListStatusesByRef', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListStatusesByRef', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoListStatusesByRef', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListSubscribers: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListSubscribers', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListSubscribers', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscribers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTags: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListTags', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListTags', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTeams: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListTeams', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListTeams', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTopics: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListTopics', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListTopics', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMergePullRequest: async (owner: string, repo: string, index: number, body?: MergePullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoMergePullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoMergePullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoMergePullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMigrate: async (body?: MigrateRepoOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/migrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMirrorSync: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoMirrorSync', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoMirrorSync', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/mirror-sync`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns if new Issue Pins are allowed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoNewPinAllowed: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoNewPinAllowed', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoNewPinAllowed', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/new_pin_allowed`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPullRequestIsMerged: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoPullRequestIsMerged', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoPullRequestIsMerged', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoPullRequestIsMerged', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync all push mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPushMirrorSync: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoPushMirrorSync', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoPushMirrorSync', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/push_mirrors-sync`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSearch: async (q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (includeDesc !== undefined) {
                localVarQueryParameter['includeDesc'] = includeDesc;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (priorityOwnerId !== undefined) {
                localVarQueryParameter['priority_owner_id'] = priorityOwnerId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (starredBy !== undefined) {
                localVarQueryParameter['starredBy'] = starredBy;
            }

            if (_private !== undefined) {
                localVarQueryParameter['private'] = _private;
            }

            if (isPrivate !== undefined) {
                localVarQueryParameter['is_private'] = isPrivate;
            }

            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (exclusive !== undefined) {
                localVarQueryParameter['exclusive'] = exclusive;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSigningKey: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoSigningKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoSigningKey', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/signing-key.gpg`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {SubmitPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSubmitPullReview: async (owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTestHook: async (owner: string, repo: string, id: number, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoTestHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoTestHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoTestHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}/tests`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTrackedTimes: async (owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoTrackedTimes', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoTrackedTimes', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {TransferRepoOption} body Transfer Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTransfer: async (owner: string, repo: string, body: TransferRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoTransfer', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoTransfer', 'repo', repo)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoTransfer', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/transfer`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUnDismissPullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateFile: async (owner: string, repo: string, filepath: string, body: UpdateFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdateFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdateFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoUpdateFile', 'filepath', filepath)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoUpdateFile', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge PR\'s baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdatePullRequest: async (owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdatePullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdatePullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoUpdatePullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/update`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateTopics: async (owner: string, repo: string, body?: RepoTopicOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdateTopics', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdateTopics', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the validation information for a issue config
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoValidateIssueConfig: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoValidateIssueConfig', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoValidateIssueConfig', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issue_config/validate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSearch: async (q: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('topicSearch', 'q', q)
            const localVarPath = `/topics/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentCheckSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentCheckSubscription', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentDeleteSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentDeleteSubscription', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentPutSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentPutSubscription', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a user\'s tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userTrackedTimes: async (owner: string, repo: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userTrackedTimes', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userTrackedTimes', 'repo', repo)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('userTrackedTimes', 'user', user)
            const localVarPath = `/repos/{owner}/{repo}/times/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptRepoTransfer(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCurrentUserRepo(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFork(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateRepo(templateOwner, templateRepo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotatedTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotatedTag(owner, repo, sha, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitBlobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlob(owner, repo, sha, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTreeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTree(owner, repo, sha, recursive, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForks(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectRepoTransfer(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddCollaborator(owner, repo, collaborator, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary add a push mirror to the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePushMirrorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddPushMirror(owner: string, repo: string, body?: CreatePushMirrorOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushMirror>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddPushMirror(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddTeam(owner, repo, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddTopic(owner, repo, topic, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply diff patch to repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoApplyDiffPatch(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel the scheduled auto merge for the given pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCancelScheduledAutoMerge(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify multiple files in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {ChangeFilesOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoChangeFiles(owner: string, repo: string, body: ChangeFilesOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoChangeFiles(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCheckCollaborator(owner, repo, collaborator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCheckTeam(owner, repo, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateBranch(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateBranchProtection(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {CreateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateFile(owner, repo, filepath, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateHook(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateKey(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreatePullRequest(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {CreatePullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreatePullReview(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreatePullReviewRequests(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateRelease(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateReleaseAttachment(owner, repo, id, attachment, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateStatus(owner, repo, sha, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateTag(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateWikiPage(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDelete(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDelete(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteBranch(owner, repo, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteBranchProtection(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteCollaborator(owner, repo, collaborator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {DeleteFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteFile(owner, repo, filepath, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteGitHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteKey(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeletePullReview(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeletePullReviewRequests(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletes a push mirror from a repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of the pushMirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePushMirror(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeletePushMirror(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteRelease(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteReleaseByTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a repository\'s tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteTeam(owner, repo, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteTopic(owner, repo, topic, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteWikiPage(owner, repo, pageName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {DismissPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDismissPullReview(owner, repo, index, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a repository\'s properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEdit(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditBranchProtection(owner, repo, name, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditGitHook(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditHook(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditPullRequest(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditRelease(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditWikiPage(owner, repo, pageName, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGet(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGet(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
         * @param {string} [path] filepath of a file/dir
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
         * @param {string} [not] commits that match the given specifier will not be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Commit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetAllCommits(owner, repo, sha, path, stat, verification, files, page, limit, not, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetArchive(owner, repo, archive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetAssignees(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetBranch(owner, repo, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetBranchProtection(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetByID(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetByID(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CombinedStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetContents(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContentsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetContentsList(owner, repo, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetEditorConfig(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetGitHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the issue config for a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetIssueConfig(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IssueTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetIssueTemplates(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a repository\'s key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetKey(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetLanguages(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetLatestRelease(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetLatestRelease(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetNote(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetNote(owner, repo, sha, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullRequest(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Commit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullRequestCommits(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get changed files for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} [skipTo] skip to given file
         * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequestFiles(owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChangedFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullRequestFiles(owner, repo, index, skipTo, whitespace, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullReview(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReviewComment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullReviewComments(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get push mirror of the repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of push mirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPushMirrorByRemoteName(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushMirror>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPushMirrorByRemoteName(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRawFile(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a file or it\'s LFS object from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRawFileOrLFS(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRelease(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetReleaseAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetReleaseByTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get repository permissions for a user
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoCollaboratorPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRepoPermissions(owner, repo, collaborator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetReviewers(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetSingleCommit(owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetSingleCommit(owner, repo, sha, stat, verification, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetWikiPage(owner, repo, pageName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiCommitList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetWikiPageRevisions(owner, repo, pageName, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WikiPageMetaData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetWikiPages(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s activity feeds
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListActivityFeeds(owner: string, repo: string, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Activity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListActivityFeeds(owner, repo, date, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListAllGitRefs(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BranchProtection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListBranchProtection(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListBranches(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListCollaborators(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GitHook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListGitHooks(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListGitRefs(owner, repo, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListHooks(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeployKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListKeys(owner, repo, keyId, fingerprint, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s pinned issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPinnedIssues(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPinnedIssues(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s pinned pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPinnedPullRequests(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPinnedPullRequests(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
         * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullRequests(owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPullReviews(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all push mirrors of the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPushMirrors(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PushMirror>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPushMirrors(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List release\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListReleaseAttachments(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Release>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListStargazers(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {RepoListStatusesSortEnum} [sort] type of sort
         * @param {RepoListStatusesStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatuses(owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListStatuses(owner, repo, sha, sort, state, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
         * @param {RepoListStatusesByRefStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListSubscribers(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListTags(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListTeams(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicName>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListTopics(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoMergePullRequest(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoMigrate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoMirrorSync(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns if new Issue Pins are allowed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoNewPinAllowed(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewIssuePinsAllowed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoNewPinAllowed(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoPullRequestIsMerged(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync all push mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoPushMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoPushMirrorSync(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoSigningKey(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {SubmitPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoSubmitPullReview(owner, repo, index, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoTestHook(owner, repo, id, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoTrackedTimes(owner, repo, user, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {TransferRepoOption} body Transfer Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoTransfer(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUnDismissPullReview(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdateFile(owner, repo, filepath, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Merge PR\'s baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdatePullRequest(owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdatePullRequest(owner, repo, index, style, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdateTopics(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the validation information for a issue config
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoValidateIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueConfigValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoValidateIssueConfig(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopicResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topicSearch(q, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentCheckSubscription(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteSubscription(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPutSubscription(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a user\'s tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTrackedTimes(owner, repo, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptRepoTransfer(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.acceptRepoTransfer(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo(body?: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createCurrentUserRepo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFork(owner: string, repo: string, body?: CreateForkOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createFork(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.generateRepo(templateOwner, templateRepo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotatedTag(owner: string, repo: string, sha: string, options?: any): AxiosPromise<AnnotatedTag> {
            return localVarFp.getAnnotatedTag(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlob(owner: string, repo: string, sha: string, options?: any): AxiosPromise<GitBlobResponse> {
            return localVarFp.getBlob(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<GitTreeResponse> {
            return localVarFp.getTree(owner, repo, sha, recursive, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForks(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.listForks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectRepoTransfer(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.rejectRepoTransfer(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: any): AxiosPromise<void> {
            return localVarFp.repoAddCollaborator(owner, repo, collaborator, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary add a push mirror to the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePushMirrorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddPushMirror(owner: string, repo: string, body?: CreatePushMirrorOption, options?: any): AxiosPromise<PushMirror> {
            return localVarFp.repoAddPushMirror(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoAddTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTopic(owner: string, repo: string, topic: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoAddTopic(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply diff patch to repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.repoApplyDiffPatch(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel the scheduled auto merge for the given pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoCancelScheduledAutoMerge(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify multiple files in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {ChangeFilesOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoChangeFiles(owner: string, repo: string, body: ChangeFilesOptions, options?: any): AxiosPromise<FilesResponse> {
            return localVarFp.repoChangeFiles(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoCheckCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<Team> {
            return localVarFp.repoCheckTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: any): AxiosPromise<Branch> {
            return localVarFp.repoCreateBranch(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: any): AxiosPromise<BranchProtection> {
            return localVarFp.repoCreateBranchProtection(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {CreateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.repoCreateFile(owner, repo, filepath, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.repoCreateHook(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: any): AxiosPromise<DeployKey> {
            return localVarFp.repoCreateKey(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: any): AxiosPromise<PullRequest> {
            return localVarFp.repoCreatePullRequest(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {CreatePullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoCreatePullReview(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: any): AxiosPromise<Array<PullReview>> {
            return localVarFp.repoCreatePullReviewRequests(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: any): AxiosPromise<Release> {
            return localVarFp.repoCreateRelease(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: any): AxiosPromise<Attachment> {
            return localVarFp.repoCreateReleaseAttachment(owner, repo, id, attachment, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: any): AxiosPromise<CommitStatus> {
            return localVarFp.repoCreateStatus(owner, repo, sha, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: any): AxiosPromise<Tag> {
            return localVarFp.repoCreateTag(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: any): AxiosPromise<WikiPage> {
            return localVarFp.repoCreateWikiPage(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDelete(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDelete(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranch(owner: string, repo: string, branch: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {DeleteFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: any): AxiosPromise<FileDeleteResponse> {
            return localVarFp.repoDeleteFile(owner, repo, filepath, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitHook(owner: string, repo: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteHook(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteKey(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeletePullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeletePullReviewRequests(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletes a push mirror from a repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of the pushMirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePushMirror(owner: string, repo: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeletePushMirror(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteRelease(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a repository\'s tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTopic(owner: string, repo: string, topic: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteTopic(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteWikiPage(owner, repo, pageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {DismissPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoDismissPullReview(owner, repo, index, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options?: any): AxiosPromise<string> {
            return localVarFp.repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a repository\'s properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoEdit(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: any): AxiosPromise<BranchProtection> {
            return localVarFp.repoEditBranchProtection(owner, repo, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: any): AxiosPromise<GitHook> {
            return localVarFp.repoEditGitHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.repoEditHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: any): AxiosPromise<PullRequest> {
            return localVarFp.repoEditPullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: any): AxiosPromise<Release> {
            return localVarFp.repoEditRelease(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: any): AxiosPromise<Attachment> {
            return localVarFp.repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: any): AxiosPromise<WikiPage> {
            return localVarFp.repoEditWikiPage(owner, repo, pageName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGet(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoGet(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
         * @param {string} [path] filepath of a file/dir
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
         * @param {string} [not] commits that match the given specifier will not be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options?: any): AxiosPromise<Array<Commit>> {
            return localVarFp.repoGetAllCommits(owner, repo, sha, path, stat, verification, files, page, limit, not, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetArchive(owner: string, repo: string, archive: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetArchive(owner, repo, archive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAssignees(owner: string, repo: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoGetAssignees(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranch(owner: string, repo: string, branch: string, options?: any): AxiosPromise<Branch> {
            return localVarFp.repoGetBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranchProtection(owner: string, repo: string, name: string, options?: any): AxiosPromise<BranchProtection> {
            return localVarFp.repoGetBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetByID(id: number, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoGetByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: any): AxiosPromise<CombinedStatus> {
            return localVarFp.repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<ContentsResponse> {
            return localVarFp.repoGetContents(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContentsList(owner: string, repo: string, ref?: string, options?: any): AxiosPromise<Array<ContentsResponse>> {
            return localVarFp.repoGetContentsList(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetEditorConfig(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetGitHook(owner: string, repo: string, id: string, options?: any): AxiosPromise<GitHook> {
            return localVarFp.repoGetGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetHook(owner: string, repo: string, id: number, options?: any): AxiosPromise<Hook> {
            return localVarFp.repoGetHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the issue config for a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueConfig(owner: string, repo: string, options?: any): AxiosPromise<IssueConfig> {
            return localVarFp.repoGetIssueConfig(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueTemplates(owner: string, repo: string, options?: any): AxiosPromise<Array<IssueTemplate>> {
            return localVarFp.repoGetIssueTemplates(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository\'s key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetKey(owner: string, repo: string, id: number, options?: any): AxiosPromise<DeployKey> {
            return localVarFp.repoGetKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLanguages(owner: string, repo: string, options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.repoGetLanguages(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLatestRelease(owner: string, repo: string, options?: any): AxiosPromise<Release> {
            return localVarFp.repoGetLatestRelease(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetNote(owner: string, repo: string, sha: string, options?: any): AxiosPromise<Note> {
            return localVarFp.repoGetNote(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequest(owner: string, repo: string, index: number, options?: any): AxiosPromise<PullRequest> {
            return localVarFp.repoGetPullRequest(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Commit>> {
            return localVarFp.repoGetPullRequestCommits(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get changed files for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {string} [skipTo] skip to given file
         * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestFiles(owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options?: any): AxiosPromise<Array<ChangedFile>> {
            return localVarFp.repoGetPullRequestFiles(owner, repo, index, skipTo, whitespace, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoGetPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<Array<PullReviewComment>> {
            return localVarFp.repoGetPullReviewComments(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get push mirror of the repository by remoteName
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name remote name of push mirror
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPushMirrorByRemoteName(owner: string, repo: string, name: string, options?: any): AxiosPromise<PushMirror> {
            return localVarFp.repoGetPushMirrorByRemoteName(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetRawFile(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file or it\'s LFS object from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetRawFileOrLFS(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRelease(owner: string, repo: string, id: number, options?: any): AxiosPromise<Release> {
            return localVarFp.repoGetRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<Attachment> {
            return localVarFp.repoGetReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<Release> {
            return localVarFp.repoGetReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get repository permissions for a user
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<RepoCollaboratorPermission> {
            return localVarFp.repoGetRepoPermissions(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReviewers(owner: string, repo: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoGetReviewers(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetSingleCommit(owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options?: any): AxiosPromise<Commit> {
            return localVarFp.repoGetSingleCommit(owner, repo, sha, stat, verification, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.repoGetTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPage(owner: string, repo: string, pageName: string, options?: any): AxiosPromise<WikiPage> {
            return localVarFp.repoGetWikiPage(owner, repo, pageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: any): AxiosPromise<WikiCommitList> {
            return localVarFp.repoGetWikiPageRevisions(owner, repo, pageName, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<WikiPageMetaData>> {
            return localVarFp.repoGetWikiPages(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s activity feeds
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListActivityFeeds(owner: string, repo: string, date?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Activity>> {
            return localVarFp.repoListActivityFeeds(owner, repo, date, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListAllGitRefs(owner: string, repo: string, options?: any): AxiosPromise<Array<Reference>> {
            return localVarFp.repoListAllGitRefs(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranchProtection(owner: string, repo: string, options?: any): AxiosPromise<Array<BranchProtection>> {
            return localVarFp.repoListBranchProtection(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Branch>> {
            return localVarFp.repoListBranches(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoListCollaborators(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitHooks(owner: string, repo: string, options?: any): AxiosPromise<Array<GitHook>> {
            return localVarFp.repoListGitHooks(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitRefs(owner: string, repo: string, ref: string, options?: any): AxiosPromise<Array<Reference>> {
            return localVarFp.repoListGitRefs(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Hook>> {
            return localVarFp.repoListHooks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<DeployKey>> {
            return localVarFp.repoListKeys(owner, repo, keyId, fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s pinned issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPinnedIssues(owner: string, repo: string, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.repoListPinnedIssues(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s pinned pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPinnedPullRequests(owner: string, repo: string, options?: any): AxiosPromise<Array<PullRequest>> {
            return localVarFp.repoListPinnedPullRequests(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
         * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullRequests(owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: any): AxiosPromise<Array<PullRequest>> {
            return localVarFp.repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<PullReview>> {
            return localVarFp.repoListPullReviews(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all push mirrors of the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPushMirrors(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<PushMirror>> {
            return localVarFp.repoListPushMirrors(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List release\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleaseAttachments(owner: string, repo: string, id: number, options?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.repoListReleaseAttachments(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Release>> {
            return localVarFp.repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoListStargazers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {RepoListStatusesSortEnum} [sort] type of sort
         * @param {RepoListStatusesStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatuses(owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options?: any): AxiosPromise<Array<CommitStatus>> {
            return localVarFp.repoListStatuses(owner, repo, sha, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
         * @param {RepoListStatusesByRefStateEnum} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options?: any): AxiosPromise<Array<CommitStatus>> {
            return localVarFp.repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoListSubscribers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.repoListTags(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTeams(owner: string, repo: string, options?: any): AxiosPromise<Array<Team>> {
            return localVarFp.repoListTeams(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<TopicName> {
            return localVarFp.repoListTopics(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: any): AxiosPromise<void> {
            return localVarFp.repoMergePullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMigrate(body?: MigrateRepoOptions, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoMigrate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMirrorSync(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoMirrorSync(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns if new Issue Pins are allowed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoNewPinAllowed(owner: string, repo: string, options?: any): AxiosPromise<NewIssuePinsAllowed> {
            return localVarFp.repoNewPinAllowed(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoPullRequestIsMerged(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync all push mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPushMirrorSync(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoPushMirrorSync(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: any): AxiosPromise<SearchResults> {
            return localVarFp.repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSigningKey(owner: string, repo: string, options?: any): AxiosPromise<string> {
            return localVarFp.repoSigningKey(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {SubmitPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoSubmitPullReview(owner, repo, index, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoTestHook(owner, repo, id, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.repoTrackedTimes(owner, repo, user, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {TransferRepoOption} body Transfer Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoTransfer(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoUnDismissPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.repoUpdateFile(owner, repo, filepath, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge PR\'s baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdatePullRequest(owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options?: any): AxiosPromise<void> {
            return localVarFp.repoUpdatePullRequest(owner, repo, index, style, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: any): AxiosPromise<void> {
            return localVarFp.repoUpdateTopics(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the validation information for a issue config
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoValidateIssueConfig(owner: string, repo: string, options?: any): AxiosPromise<IssueConfigValidation> {
            return localVarFp.repoValidateIssueConfig(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSearch(q: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TopicResponse>> {
            return localVarFp.topicSearch(q, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckSubscription(owner: string, repo: string, options?: any): AxiosPromise<WatchInfo> {
            return localVarFp.userCurrentCheckSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteSubscription(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutSubscription(owner: string, repo: string, options?: any): AxiosPromise<WatchInfo> {
            return localVarFp.userCurrentPutSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a user\'s tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userTrackedTimes(owner: string, repo: string, user: string, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.userTrackedTimes(owner, repo, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - interface
 * @export
 * @interface RepositoryApi
 */
export interface RepositoryApiInterface {
    /**
     * 
     * @summary Accept a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Create a repository
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Fork a repository
     * @param {string} owner owner of the repo to fork
     * @param {string} repo name of the repo to fork
     * @param {CreateForkOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Create a repository using a template
     * @param {string} templateOwner name of the template repository owner
     * @param {string} templateRepo name of the template repository
     * @param {GenerateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Gets the tag object of an annotated tag (not lightweight tags)
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): AxiosPromise<AnnotatedTag>;

    /**
     * 
     * @summary Gets the blob of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): AxiosPromise<GitBlobResponse>;

    /**
     * 
     * @summary Gets the tree of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {boolean} [recursive] show all directories and files
     * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
     * @param {number} [perPage] number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig): AxiosPromise<GitTreeResponse>;

    /**
     * 
     * @summary List a repository\'s forks
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary Reject a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Add a collaborator to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to add
     * @param {AddCollaboratorOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary add a push mirror to the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePushMirrorOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoAddPushMirror(owner: string, repo: string, body?: CreatePushMirrorOption, options?: AxiosRequestConfig): AxiosPromise<PushMirror>;

    /**
     * 
     * @summary Add a team to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Add a topic to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Apply diff patch to repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {UpdateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: AxiosRequestConfig): AxiosPromise<FileResponse>;

    /**
     * 
     * @summary Cancel the scheduled auto merge for the given pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Modify multiple files in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {ChangeFilesOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoChangeFiles(owner: string, repo: string, body: ChangeFilesOptions, options?: AxiosRequestConfig): AxiosPromise<FilesResponse>;

    /**
     * 
     * @summary Check if a user is a collaborator of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Check if a team is assigned to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): AxiosPromise<Team>;

    /**
     * 
     * @summary Create a branch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig): AxiosPromise<Branch>;

    /**
     * 
     * @summary Create a branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig): AxiosPromise<BranchProtection>;

    /**
     * 
     * @summary Create a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to create
     * @param {CreateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: AxiosRequestConfig): AxiosPromise<FileResponse>;

    /**
     * 
     * @summary Create a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Add a key to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateKeyOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig): AxiosPromise<DeployKey>;

    /**
     * 
     * @summary Create a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig): AxiosPromise<PullRequest>;

    /**
     * 
     * @summary Create a review to an pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {CreatePullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary create review requests for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {PullReviewRequestOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): AxiosPromise<Array<PullReview>>;

    /**
     * 
     * @summary Create a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Create a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Create a commit status
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {CreateStatusOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig): AxiosPromise<CommitStatus>;

    /**
     * 
     * @summary Create a new git tag in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateTagOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig): AxiosPromise<Tag>;

    /**
     * 
     * @summary Create a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): AxiosPromise<WikiPage>;

    /**
     * 
     * @summary Delete a repository
     * @param {string} owner owner of the repo to delete
     * @param {string} repo name of the repo to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDelete(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a specific branch from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a collaborator from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to delete
     * @param {DeleteFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: AxiosRequestConfig): AxiosPromise<FileDeleteResponse>;

    /**
     * 
     * @summary Delete a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a key from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a specific review from a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary cancel review requests for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {PullReviewRequestOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary deletes a push mirror from a repository by remoteName
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name remote name of the pushMirror
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeletePushMirror(owner: string, repo: string, name: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a repository\'s tag by name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a team from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a topic from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {DismissPullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary Get a commit\'s diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha SHA of the commit to get
     * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Get a pull request diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
     * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Edit a repository\'s properties. Only fields that are set will be changed.
     * @param {string} owner owner of the repo to edit
     * @param {string} repo name of the repo to edit
     * @param {EditRepoOption} [body] Properties of a repo that you can edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Edit a branch protections for a repository. Only fields that are set will be changed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {EditBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig): AxiosPromise<BranchProtection>;

    /**
     * 
     * @summary Edit a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {EditGitHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig): AxiosPromise<GitHook>;

    /**
     * 
     * @summary Edit a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id index of the hook
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to edit
     * @param {EditPullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig): AxiosPromise<PullRequest>;

    /**
     * 
     * @summary Update a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to edit
     * @param {EditReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Edit a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Edit a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): AxiosPromise<WikiPage>;

    /**
     * 
     * @summary Get a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGet(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Get a list of all commits from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
     * @param {string} [path] filepath of a file/dir
     * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
     * @param {string} [not] commits that match the given specifier will not be listed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options?: AxiosRequestConfig): AxiosPromise<Array<Commit>>;

    /**
     * 
     * @summary Get an archive of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Return all users that have write access and can be assigned to issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary Retrieve a specific branch from a repository, including its effective branch protection
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): AxiosPromise<Branch>;

    /**
     * 
     * @summary Get a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): AxiosPromise<BranchProtection>;

    /**
     * 
     * @summary Get a repository by id
     * @param {number} id id of the repo to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetByID(id: number, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Get a commit\'s combined status, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<CombinedStatus>;

    /**
     * 
     * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the dir, file, symlink or submodule in the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<ContentsResponse>;

    /**
     * 
     * @summary Gets the metadata of all the entries of the root dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<Array<ContentsResponse>>;

    /**
     * 
     * @summary Get the EditorConfig definitions of a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a Git hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): AxiosPromise<GitHook>;

    /**
     * 
     * @summary Get a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Returns the issue config for a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<IssueConfig>;

    /**
     * 
     * @summary Get available issue templates for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<IssueTemplate>>;

    /**
     * 
     * @summary Get a repository\'s key by id
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<DeployKey>;

    /**
     * 
     * @summary Get languages and number of bytes of code written
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: number; }>;

    /**
     * 
     * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetLatestRelease(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Get a note corresponding to a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetNote(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): AxiosPromise<Note>;

    /**
     * 
     * @summary Get a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<PullRequest>;

    /**
     * 
     * @summary Get commits for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Commit>>;

    /**
     * 
     * @summary Get changed files for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {string} [skipTo] skip to given file
     * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullRequestFiles(owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<ChangedFile>>;

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<Array<PullReviewComment>>;

    /**
     * 
     * @summary Get push mirror of the repository by remoteName
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name remote name of push mirror
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetPushMirrorByRemoteName(owner: string, repo: string, name: string, options?: AxiosRequestConfig): AxiosPromise<PushMirror>;

    /**
     * 
     * @summary Get a file from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a file or it\'s LFS object from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Get a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Get a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): AxiosPromise<Release>;

    /**
     * 
     * @summary Get repository permissions for a user
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): AxiosPromise<RepoCollaboratorPermission>;

    /**
     * 
     * @summary Return all users that can be requested to review in this repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary Get a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetSingleCommit(owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options?: AxiosRequestConfig): AxiosPromise<Commit>;

    /**
     * 
     * @summary Get the tag of a repository by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): AxiosPromise<Tag>;

    /**
     * 
     * @summary Get a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): AxiosPromise<WikiPage>;

    /**
     * 
     * @summary Get revisions of a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {number} [page] page number of results to return (1-based)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig): AxiosPromise<WikiCommitList>;

    /**
     * 
     * @summary Get all wiki pages
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<WikiPageMetaData>>;

    /**
     * 
     * @summary List a repository\'s activity feeds
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListActivityFeeds(owner: string, repo: string, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Activity>>;

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<Reference>>;

    /**
     * 
     * @summary List branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<BranchProtection>>;

    /**
     * 
     * @summary List a repository\'s branches
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Branch>>;

    /**
     * 
     * @summary List a repository\'s collaborators
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the Git hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<GitHook>>;

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref part or full name of the ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig): AxiosPromise<Array<Reference>>;

    /**
     * 
     * @summary List the hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Hook>>;

    /**
     * 
     * @summary List a repository\'s keys
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [keyId] the key_id to search for
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<DeployKey>>;

    /**
     * 
     * @summary List a repo\'s pinned issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPinnedIssues(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary List a repo\'s pinned pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPinnedPullRequests(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<PullRequest>>;

    /**
     * 
     * @summary List a repo\'s pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
     * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
     * @param {number} [milestone] ID of the milestone
     * @param {Array<number>} [labels] Label IDs
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPullRequests(owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PullRequest>>;

    /**
     * 
     * @summary List all reviews for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PullReview>>;

    /**
     * 
     * @summary Get all push mirrors of the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListPushMirrors(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PushMirror>>;

    /**
     * 
     * @summary List release\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Array<Attachment>>;

    /**
     * 
     * @summary List a repo\'s releases
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
     * @param {boolean} [preRelease] filter (exclude / include) pre-releases
     * @param {number} [perPage] page size of results, deprecated - use limit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Release>>;

    /**
     * 
     * @summary List a repo\'s stargazers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary Get a commit\'s statuses
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {RepoListStatusesSortEnum} [sort] type of sort
     * @param {RepoListStatusesStateEnum} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListStatuses(owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<CommitStatus>>;

    /**
     * 
     * @summary Get a commit\'s statuses, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
     * @param {RepoListStatusesByRefStateEnum} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<CommitStatus>>;

    /**
     * 
     * @summary List a repo\'s watchers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List a repository\'s tags
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results, default maximum page size is 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Tag>>;

    /**
     * 
     * @summary List a repository\'s teams
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<Array<Team>>;

    /**
     * 
     * @summary Get list of topics that a repository has
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<TopicName>;

    /**
     * 
     * @summary Merge a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {MergePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Migrate a remote git repository
     * @param {MigrateRepoOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Sync a mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Returns if new Issue Pins are allowed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoNewPinAllowed(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<NewIssuePinsAllowed>;

    /**
     * 
     * @summary Check if a pull request has been merged
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Sync all push mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoPushMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Search for repositories
     * @param {string} [q] keyword
     * @param {boolean} [topic] Limit search to repositories with keyword as topic
     * @param {boolean} [includeDesc] include search of keyword within repository description
     * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
     * @param {number} [priorityOwnerId] repo owner to prioritize in the results
     * @param {number} [teamId] search only for repos that belong to the given team id
     * @param {number} [starredBy] search only for repos that the user with the given id has starred
     * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
     * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
     * @param {boolean} [template] include template repositories this user has access to (defaults to true)
     * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
     * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
     * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
     * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
     * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<SearchResults>;

    /**
     * 
     * @summary Get signing-key.gpg for given repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Submit a pending review to an pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {SubmitPullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary Test a push webhook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to test
     * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary List a repo\'s tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<TrackedTime>>;

    /**
     * 
     * @summary Transfer a repo ownership
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {TransferRepoOption} body Transfer Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Cancel to dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<PullReview>;

    /**
     * 
     * @summary Update a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to update
     * @param {UpdateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: AxiosRequestConfig): AxiosPromise<FileResponse>;

    /**
     * 
     * @summary Merge PR\'s baseBranch into headBranch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoUpdatePullRequest(owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Replace list of topics for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoTopicOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Returns the validation information for a issue config
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    repoValidateIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<IssueConfigValidation>;

    /**
     * 
     * @summary search topics via keyword
     * @param {string} q keywords to search
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<TopicResponse>>;

    /**
     * 
     * @summary Check if the current user is watching a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<WatchInfo>;

    /**
     * 
     * @summary Unwatch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Watch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<WatchInfo>;

    /**
     * 
     * @summary List a user\'s tracked times in a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} user username of user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RepositoryApiInterface
     */
    userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig): AxiosPromise<Array<TrackedTime>>;

}

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI implements RepositoryApiInterface {
    /**
     * 
     * @summary Accept a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).acceptRepoTransfer(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a repository
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).createCurrentUserRepo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fork a repository
     * @param {string} owner owner of the repo to fork
     * @param {string} repo name of the repo to fork
     * @param {CreateForkOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).createFork(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a repository using a template
     * @param {string} templateOwner name of the template repository owner
     * @param {string} templateRepo name of the template repository
     * @param {GenerateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).generateRepo(templateOwner, templateRepo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the tag object of an annotated tag (not lightweight tags)
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getAnnotatedTag(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the blob of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getBlob(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the tree of a repository.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {boolean} [recursive] show all directories and files
     * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
     * @param {number} [perPage] number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getTree(owner, repo, sha, recursive, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s forks
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).listForks(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject a repo transfer
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).rejectRepoTransfer(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a collaborator to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to add
     * @param {AddCollaboratorOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddCollaborator(owner, repo, collaborator, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary add a push mirror to the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePushMirrorOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddPushMirror(owner: string, repo: string, body?: CreatePushMirrorOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddPushMirror(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a team to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a topic to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddTopic(owner, repo, topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply diff patch to repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {UpdateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoApplyDiffPatch(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel the scheduled auto merge for the given pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCancelScheduledAutoMerge(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify multiple files in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {ChangeFilesOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoChangeFiles(owner: string, repo: string, body: ChangeFilesOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoChangeFiles(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a user is a collaborator of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCheckCollaborator(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a team is assigned to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCheckTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a branch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateBranch(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateBranchProtection(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to create
     * @param {CreateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateFile(owner, repo, filepath, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateHook(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a key to a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateKeyOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateKey(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreatePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreatePullRequest(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a review to an pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {CreatePullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreatePullReview(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create review requests for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {PullReviewRequestOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreatePullReviewRequests(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateRelease(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateReleaseAttachment(owner, repo, id, attachment, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a commit status
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {CreateStatusOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateStatus(owner, repo, sha, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new git tag in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateTagOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateTag(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateWikiPage(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a repository
     * @param {string} owner owner of the repo to delete
     * @param {string} repo name of the repo to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDelete(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDelete(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific branch from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteBranch(owner, repo, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteBranchProtection(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a collaborator from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteCollaborator(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to delete
     * @param {DeleteFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteFile(owner, repo, filepath, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteGitHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a key from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteKey(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific review from a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeletePullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel review requests for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {PullReviewRequestOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeletePullReviewRequests(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletes a push mirror from a repository by remoteName
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name remote name of the pushMirror
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePushMirror(owner: string, repo: string, name: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeletePushMirror(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteRelease(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseByTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a repository\'s tag by name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a team from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} team team name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteTeam(owner, repo, team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a topic from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} topic name of the topic to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteTopic(owner, repo, topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteWikiPage(owner, repo, pageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {DismissPullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDismissPullReview(owner, repo, index, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha SHA of the commit to get
     * @param {RepoDownloadCommitDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: RepoDownloadCommitDiffOrPatchDiffTypeEnum, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a pull request diff or patch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {RepoDownloadPullDiffOrPatchDiffTypeEnum} diffType whether the output is diff or patch
     * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: RepoDownloadPullDiffOrPatchDiffTypeEnum, binary?: boolean, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a repository\'s properties. Only fields that are set will be changed.
     * @param {string} owner owner of the repo to edit
     * @param {string} repo name of the repo to edit
     * @param {EditRepoOption} [body] Properties of a repo that you can edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEdit(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a branch protections for a repository. Only fields that are set will be changed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {EditBranchProtectionOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditBranchProtection(owner, repo, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a Git hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {EditGitHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditGitHook(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a hook in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id index of the hook
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditHook(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to edit
     * @param {EditPullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditPullRequest(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to edit
     * @param {EditReleaseOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditRelease(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {CreateWikiPageOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditWikiPage(owner, repo, pageName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGet(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGet(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all commits from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
     * @param {string} [path] filepath of a file/dir
     * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
     * @param {string} [not] commits that match the given specifier will not be listed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, stat?: boolean, verification?: boolean, files?: boolean, page?: number, limit?: number, not?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetAllCommits(owner, repo, sha, path, stat, verification, files, page, limit, not, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an archive of a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetArchive(owner, repo, archive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all users that have write access and can be assigned to issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetAssignees(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a specific branch from a repository, including its effective branch protection
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} branch branch to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetBranch(owner, repo, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific branch protection for the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name name of protected branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetBranchProtection(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a repository by id
     * @param {number} id id of the repo to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetByID(id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetByID(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s combined status, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the dir, file, symlink or submodule in the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetContents(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the metadata of all the entries of the root dir
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetContentsList(owner, repo, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the EditorConfig definitions of a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetEditorConfig(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Git hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetGitHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a hook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetHook(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the issue config for a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetIssueConfig(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get available issue templates for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetIssueTemplates(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a repository\'s key by id
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetKey(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get languages and number of bytes of code written
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetLanguages(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetLatestRelease(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetLatestRelease(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a note corresponding to a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetNote(owner: string, repo: string, sha: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetNote(owner, repo, sha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullRequest(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get commits for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullRequestCommits(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get changed files for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {string} [skipTo] skip to given file
     * @param {RepoGetPullRequestFilesWhitespaceEnum} [whitespace] whitespace behavior
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullRequestFiles(owner: string, repo: string, index: number, skipTo?: string, whitespace?: RepoGetPullRequestFilesWhitespaceEnum, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullRequestFiles(owner, repo, index, skipTo, whitespace, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullReviewComments(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get push mirror of the repository by remoteName
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} name remote name of push mirror
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPushMirrorByRemoteName(owner: string, repo: string, name: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPushMirrorByRemoteName(owner, repo, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRawFile(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file or it\'s LFS object from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath filepath of the file to get
     * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRawFileOrLFS(owner, repo, filepath, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a release
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRelease(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a release attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a release by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag tag name of the release to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetReleaseByTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get repository permissions for a user
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} collaborator username of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRepoPermissions(owner, repo, collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all users that can be requested to review in this repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetReviewers(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single commit from a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha a git ref or commit sha
     * @param {boolean} [stat] include diff stats for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [verification] include verification for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {boolean} [files] include a list of affected files for every commit (disable for speedup, default \&#39;true\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetSingleCommit(owner: string, repo: string, sha: string, stat?: boolean, verification?: boolean, files?: boolean, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetSingleCommit(owner, repo, sha, stat, verification, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the tag of a repository by tag name
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} tag name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetTag(owner, repo, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetWikiPage(owner, repo, pageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get revisions of a wiki page
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} pageName name of the page
     * @param {number} [page] page number of results to return (1-based)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetWikiPageRevisions(owner, repo, pageName, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all wiki pages
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetWikiPages(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s activity feeds
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListActivityFeeds(owner: string, repo: string, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListActivityFeeds(owner, repo, date, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListAllGitRefs(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List branch protections for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListBranchProtection(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s branches
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListBranches(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s collaborators
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListCollaborators(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the Git hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListGitHooks(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref part or full name of the ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListGitRefs(owner, repo, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the hooks in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListHooks(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s keys
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [keyId] the key_id to search for
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListKeys(owner, repo, keyId, fingerprint, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s pinned issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPinnedIssues(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPinnedIssues(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s pinned pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPinnedPullRequests(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPinnedPullRequests(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s pull requests
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoListPullRequestsStateEnum} [state] State of pull request: open or closed (optional)
     * @param {RepoListPullRequestsSortEnum} [sort] Type of sort
     * @param {number} [milestone] ID of the milestone
     * @param {Array<number>} [labels] Label IDs
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPullRequests(owner: string, repo: string, state?: RepoListPullRequestsStateEnum, sort?: RepoListPullRequestsSortEnum, milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all reviews for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPullReviews(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all push mirrors of the repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPushMirrors(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPushMirrors(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List release\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListReleaseAttachments(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s releases
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
     * @param {boolean} [preRelease] filter (exclude / include) pre-releases
     * @param {number} [perPage] page size of results, deprecated - use limit
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s stargazers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListStargazers(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s statuses
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} sha sha of the commit
     * @param {RepoListStatusesSortEnum} [sort] type of sort
     * @param {RepoListStatusesStateEnum} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStatuses(owner: string, repo: string, sha: string, sort?: RepoListStatusesSortEnum, state?: RepoListStatusesStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListStatuses(owner, repo, sha, sort, state, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s statuses, by branch/tag/commit reference
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} ref name of branch/tag/commit
     * @param {RepoListStatusesByRefSortEnum} [sort] type of sort
     * @param {RepoListStatusesByRefStateEnum} [state] type of state
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: RepoListStatusesByRefSortEnum, state?: RepoListStatusesByRefStateEnum, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s watchers
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListSubscribers(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s tags
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results, default maximum page size is 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListTags(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s teams
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListTeams(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of topics that a repository has
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListTopics(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merge a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to merge
     * @param {MergePullRequestOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoMergePullRequest(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Migrate a remote git repository
     * @param {MigrateRepoOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoMigrate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync a mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoMirrorSync(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns if new Issue Pins are allowed
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoNewPinAllowed(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoNewPinAllowed(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a pull request has been merged
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoPullRequestIsMerged(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync all push mirrored repository
     * @param {string} owner owner of the repo to sync
     * @param {string} repo name of the repo to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoPushMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoPushMirrorSync(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for repositories
     * @param {string} [q] keyword
     * @param {boolean} [topic] Limit search to repositories with keyword as topic
     * @param {boolean} [includeDesc] include search of keyword within repository description
     * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
     * @param {number} [priorityOwnerId] repo owner to prioritize in the results
     * @param {number} [teamId] search only for repos that belong to the given team id
     * @param {number} [starredBy] search only for repos that the user with the given id has starred
     * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
     * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
     * @param {boolean} [template] include template repositories this user has access to (defaults to true)
     * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
     * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
     * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
     * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
     * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get signing-key.gpg for given repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoSigningKey(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a pending review to an pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {SubmitPullReviewOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoSubmitPullReview(owner, repo, index, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test a push webhook
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the hook to test
     * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoTestHook(owner, repo, id, ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoTrackedTimes(owner, repo, user, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer a repo ownership
     * @param {string} owner owner of the repo to transfer
     * @param {string} repo name of the repo to transfer
     * @param {TransferRepoOption} body Transfer Options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoTransfer(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel to dismiss a review for a pull request
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request
     * @param {number} id id of the review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUnDismissPullReview(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a file in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} filepath path of the file to update
     * @param {UpdateFileOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdateFile(owner, repo, filepath, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merge PR\'s baseBranch into headBranch
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the pull request to get
     * @param {RepoUpdatePullRequestStyleEnum} [style] how to update pull request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdatePullRequest(owner: string, repo: string, index: number, style?: RepoUpdatePullRequestStyleEnum, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdatePullRequest(owner, repo, index, style, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace list of topics for a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {RepoTopicOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdateTopics(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the validation information for a issue config
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoValidateIssueConfig(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoValidateIssueConfig(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary search topics via keyword
     * @param {string} q keywords to search
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).topicSearch(q, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if the current user is watching a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userCurrentCheckSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unwatch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userCurrentDeleteSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Watch a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userCurrentPutSubscription(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a user\'s tracked times in a repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} user username of user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userTrackedTimes(owner, repo, user, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RepoDownloadCommitDiffOrPatchDiffTypeEnum = {
    Diff: 'diff',
    Patch: 'patch'
} as const;
export type RepoDownloadCommitDiffOrPatchDiffTypeEnum = typeof RepoDownloadCommitDiffOrPatchDiffTypeEnum[keyof typeof RepoDownloadCommitDiffOrPatchDiffTypeEnum];
/**
 * @export
 */
export const RepoDownloadPullDiffOrPatchDiffTypeEnum = {
    Diff: 'diff',
    Patch: 'patch'
} as const;
export type RepoDownloadPullDiffOrPatchDiffTypeEnum = typeof RepoDownloadPullDiffOrPatchDiffTypeEnum[keyof typeof RepoDownloadPullDiffOrPatchDiffTypeEnum];
/**
 * @export
 */
export const RepoGetPullRequestFilesWhitespaceEnum = {
    IgnoreAll: 'ignore-all',
    IgnoreChange: 'ignore-change',
    IgnoreEol: 'ignore-eol',
    ShowAll: 'show-all'
} as const;
export type RepoGetPullRequestFilesWhitespaceEnum = typeof RepoGetPullRequestFilesWhitespaceEnum[keyof typeof RepoGetPullRequestFilesWhitespaceEnum];
/**
 * @export
 */
export const RepoListPullRequestsStateEnum = {
    Closed: 'closed',
    Open: 'open',
    All: 'all'
} as const;
export type RepoListPullRequestsStateEnum = typeof RepoListPullRequestsStateEnum[keyof typeof RepoListPullRequestsStateEnum];
/**
 * @export
 */
export const RepoListPullRequestsSortEnum = {
    Oldest: 'oldest',
    Recentupdate: 'recentupdate',
    Leastupdate: 'leastupdate',
    Mostcomment: 'mostcomment',
    Leastcomment: 'leastcomment',
    Priority: 'priority'
} as const;
export type RepoListPullRequestsSortEnum = typeof RepoListPullRequestsSortEnum[keyof typeof RepoListPullRequestsSortEnum];
/**
 * @export
 */
export const RepoListStatusesSortEnum = {
    Oldest: 'oldest',
    Recentupdate: 'recentupdate',
    Leastupdate: 'leastupdate',
    Leastindex: 'leastindex',
    Highestindex: 'highestindex'
} as const;
export type RepoListStatusesSortEnum = typeof RepoListStatusesSortEnum[keyof typeof RepoListStatusesSortEnum];
/**
 * @export
 */
export const RepoListStatusesStateEnum = {
    Pending: 'pending',
    Success: 'success',
    Error: 'error',
    Failure: 'failure',
    Warning: 'warning'
} as const;
export type RepoListStatusesStateEnum = typeof RepoListStatusesStateEnum[keyof typeof RepoListStatusesStateEnum];
/**
 * @export
 */
export const RepoListStatusesByRefSortEnum = {
    Oldest: 'oldest',
    Recentupdate: 'recentupdate',
    Leastupdate: 'leastupdate',
    Leastindex: 'leastindex',
    Highestindex: 'highestindex'
} as const;
export type RepoListStatusesByRefSortEnum = typeof RepoListStatusesByRefSortEnum[keyof typeof RepoListStatusesByRefSortEnum];
/**
 * @export
 */
export const RepoListStatusesByRefStateEnum = {
    Pending: 'pending',
    Success: 'success',
    Error: 'error',
    Failure: 'failure',
    Warning: 'warning'
} as const;
export type RepoListStatusesByRefStateEnum = typeof RepoListStatusesByRefStateEnum[keyof typeof RepoListStatusesByRefStateEnum];
/**
 * @export
 */
export const RepoUpdatePullRequestStyleEnum = {
    Merge: 'merge',
    Rebase: 'rebase'
} as const;
export type RepoUpdatePullRequestStyleEnum = typeof RepoUpdatePullRequestStyleEnum[keyof typeof RepoUpdatePullRequestStyleEnum];
